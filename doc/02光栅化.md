##光栅化
<u>引用文章</u>:
 [<u>三角形光栅化</u>](https://blog.csdn.net/qjh5606/article/details/88915566)
[<u>光栅化Rasterization（三角形）（笔记）</u>](https://blog.csdn.net/qq_37856544/article/details/113057809)
参考百度百科的定义:[光栅化](https://baike.baidu.com/item/%E5%85%89%E6%A0%85%E5%8C%96/10008122?fr=aladdin)
***
<font color=#008000 size=3 face="黑体">光栅化（Rasterization）</font>是把顶点数据转换为片元的过程，具有将图转化为一个个栅格组成的图象的作用，特点是每个元素对应帧缓冲区中的一像素。
<br/>

####三角形的光栅化
***
&emsp;&emsp;很多问题的研究都是基于三角形之上的，我们可以把一个复杂的图形转化成很多个三角形组合的结果。 如一个矩形，我们可以将它分为两个三角形。
这是一个opengl下的例子![图片](https://learnopengl-cn.github.io/img/01/04/hellotriangle2.png)

那么如何得知一个点是否在三角形内呢
如果你有学习GAMES101的相关课程，课程中介绍的是
- Bounding Box & 向量叉积判断是否在三角形内
![图片](https://img-blog.csdnimg.cn/20210123192250767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODU2NTQ0,size_16,color_FFFFFF,t_70)

<font color=#008000 size=3 face="黑体">Bounding Box</font>
 顾名思义，即包围盒，根据三角形三个顶点，得到包围盒的最左边的x，最右边的x,顶部的y和底部的y. 然后遍历这个盒子，判断盒子中的点是否在这个三角形之内，如果在，就对它进行操作。
<font color=#008000 size=3 face="黑体">向量叉积判断是否在三角形内</font>

三角形的三个点按照逆时针顺序或者顺时针顺序组成三个向量，当Q处于三个向量的同一侧时，Q点在三个向量围成的三角形的内部。

![图片](https://img-blog.csdnimg.cn/20210123191146100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODU2NTQ0,size_16,color_FFFFFF,t_70)

所以判断三角形是否在内部的代码会像这样
```bash

static bool insideTriangle(float x, float y, const Vector3f* _v)
{   
    
      Eigen::Vector2f p;
      p<<x,y;
      Eigen::Vector2f AB=_v[1].head(2)-_v[0].head(2);
      Eigen::Vector2f BC=_v[2].head(2)-_v[1].head(2);
      Eigen::Vector2f CA=_v[0].head(2)-_v[2].head(2);
      
      Eigen::Vector2f AP=p-_v[0].head(2);
      Eigen::Vector2f BP=p-_v[1].head(2);
      Eigen::Vector2f CP=p-_v[2].head(2);
      
      return (AB[0]*AP[1]-AB[1]*AP[0]>0
           &&BC[0]*BP[1]-BC[1]*BP[0]>0
           &&CA[0]*CP[1]-CA[1]*CP[0]>0)||
           (AB[0]*AP[1]-AB[1]*AP[0]<=0
           &&BC[0]*BP[1]-BC[1]*BP[0]<=0
           &&CA[0]*CP[1]-CA[1]*CP[0]<=0)
}
```
#####特殊情况
当像素中心恰好处在线上时，要么不做处理，要么特殊处理。在这里我们不做处理。但是有些图形API中会有自己的规矩。

![图片](https://img-blog.csdnimg.cn/20210123191908922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODU2NTQ0,size_16,color_FFFFFF,t_70)


<br/>
这种方法，当三角形是狭长的那种形状的情况下，会导致bounding box很大，但是真正需要的点又很少，就大大增加了时间复杂度。于是我们寻找一种优化的方法。
<br/>
<br/>

<font color=#008000 size=3 face="黑体">每一行只找这个三角形的最左和最右，这样一个像素也不会多考虑。很适用于处理很窄并且旋转过的三角形</font>
![图片](https://img-blog.csdnimg.cn/20210123193048718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODU2NTQ0,size_16,color_FFFFFF,t_70)

- 三角形的类型
![图片](https://img-blog.csdnimg.cn/20190330170505110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FqaDU2MDY=,size_16,color_FFFFFF,t_70)

- 平底三角形光栅化
![图片](https://img-blog.csdnimg.cn/20190330170604318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FqaDU2MDY=,size_16,color_FFFFFF,t_70)
光栅化平底三角形的原理很简单，就是从上往下画横线。
在图里我们取任意的一条光栅化直线，
这条直线左边的端点x值为XL，右边的为XR。
y值就不用考虑了，因为这些线是从上往下画的，所以y就是从y0一直++，直到y1或者y2。
<br/>
- 光栅化平顶三角形
与平底三角形类似
<br/>
- 光栅化任意三角形




